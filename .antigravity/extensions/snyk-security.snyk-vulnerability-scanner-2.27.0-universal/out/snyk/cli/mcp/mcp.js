"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureCursor = exports.configureAntigravity = exports.configureWindsurf = exports.configureCopilot = exports.configureMcpHosts = void 0;
const vscode = __importStar(require("vscode"));
const logger_1 = require("../../common/logger/logger");
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path_1 = __importDefault(require("path"));
const SERVER_KEY = 'Snyk';
// Gitignore patterns for IDE-specific rule files (always use forward slashes for Git compatibility)
const COPILOT_GITIGNORE_PATTERN = '.github/instructions/snyk_rules.instructions.md';
const WINDSURF_GITIGNORE_PATTERN = '.windsurf/rules/snyk_rules.md';
const CURSOR_GITIGNORE_PATTERN = '.cursor/rules/snyk_rules.mdc';
async function configureMcpHosts(vscodeContext, configuration) {
    const appName = vscode.env.appName.toLowerCase();
    const isWindsurf = appName.includes('windsurf');
    const isCursor = appName.includes('cursor');
    const isVsCode = appName.includes('visual studio code');
    const isAntigravity = appName.includes('antigravity');
    if (isAntigravity) {
        await configureAntigravity(vscodeContext, configuration);
        return;
    }
    if (isCursor) {
        await configureCursor(vscodeContext, configuration);
        return;
    }
    if (isWindsurf) {
        await configureWindsurf(vscodeContext, configuration);
        return;
    }
    if (isVsCode) {
        await configureCopilot(vscodeContext, configuration);
        return;
    }
}
exports.configureMcpHosts = configureMcpHosts;
async function configureCopilot(vscodeContext, configuration) {
    const autoConfigureMcpServer = configuration.getAutoConfigureMcpServer();
    const secureAtInceptionExecutionFrequency = configuration.getSecureAtInceptionExecutionFrequency();
    try {
        if (autoConfigureMcpServer) {
            vscodeContext.subscriptions.push(
            /* eslint-disable @typescript-eslint/no-unsafe-argument */
            /* eslint-disable @typescript-eslint/no-unsafe-call */
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            // @ts-expect-error backward compatibility for older VS Code versions
            vscode.lm.registerMcpServerDefinitionProvider('snyk-security-scanner', {
                onDidChangeMcpServerDefinitions: new vscode.EventEmitter().event,
                provideMcpServerDefinitions: async () => {
                    // @ts-expect-error backward compatibility for older VS Code versions
                    const output = [];
                    /* eslint-disable @typescript-eslint/no-unsafe-call */
                    const cliPath = await configuration.getCliPath();
                    /* eslint-disable @typescript-eslint/no-unsafe-return */
                    const args = ['mcp', '-t', 'stdio'];
                    const snykEnv = getSnykMcpEnv(configuration);
                    const processEnv = {};
                    Object.entries(process.env).forEach(([key, value]) => {
                        processEnv[key] = value !== null && value !== void 0 ? value : '';
                    });
                    const env = { ...processEnv, ...snykEnv };
                    // @ts-expect-error backward compatibility for older VS Code versions
                    output.push(new vscode.McpStdioServerDefinition(SERVER_KEY, cliPath, args, env));
                    return output;
                },
            }));
        }
    }
    catch (err) {
        logger_1.Logger.debug(`VS Code MCP Server Definition Provider API is not available. This feature requires VS Code version > 1.101.0.`);
    }
    // Rules publishing for Copilot
    const filePath = path_1.default.join('.github', 'instructions', 'snyk_rules.instructions.md');
    try {
        if (secureAtInceptionExecutionFrequency === 'Manual') {
            // Delete rules from project
            await deleteLocalRulesForIde(filePath);
            return;
        }
        const rulesContent = await readBundledRules(vscodeContext, secureAtInceptionExecutionFrequency);
        await writeLocalRulesForIde(filePath, rulesContent);
        await ensureInGitignore([COPILOT_GITIGNORE_PATTERN]);
    }
    catch {
        logger_1.Logger.error('Failed to publish Copilot rules');
    }
}
exports.configureCopilot = configureCopilot;
async function configureWindsurf(vscodeContext, configuration) {
    const autoConfigureMcpServer = configuration.getAutoConfigureMcpServer();
    const secureAtInceptionExecutionFrequency = configuration.getSecureAtInceptionExecutionFrequency();
    try {
        if (autoConfigureMcpServer) {
            const baseDir = path_1.default.join(os.homedir(), '.codeium', 'windsurf');
            const configPath = path_1.default.join(baseDir, 'mcp_config.json');
            if (!fs.existsSync(baseDir)) {
                logger_1.Logger.debug(`Windsurf base directory not found at ${baseDir}, skipping MCP configuration.`);
            }
            else {
                const cliPath = await configuration.getCliPath();
                const env = getSnykMcpEnv(configuration);
                await ensureMcpServerInJson(configPath, SERVER_KEY, cliPath, ['mcp', '-t', 'stdio'], env);
                logger_1.Logger.debug(`Ensured Windsurf MCP config at ${configPath}`);
            }
        }
    }
    catch {
        logger_1.Logger.error('Failed to update Windsurf MCP config');
    }
    const localPath = path_1.default.join('.windsurf', 'rules', 'snyk_rules.md');
    try {
        if (secureAtInceptionExecutionFrequency === 'Manual') {
            // Delete rules from project
            await deleteLocalRulesForIde(localPath);
            return;
        }
        const rulesContent = await readBundledRules(vscodeContext, secureAtInceptionExecutionFrequency);
        await writeLocalRulesForIde(localPath, rulesContent);
        await ensureInGitignore([WINDSURF_GITIGNORE_PATTERN]);
    }
    catch {
        logger_1.Logger.error('Failed to publish Windsurf rules');
    }
}
exports.configureWindsurf = configureWindsurf;
async function configureAntigravity(vscodeContext, configuration) {
    const autoConfigureMcpServer = configuration.getAutoConfigureMcpServer();
    const secureAtInceptionExecutionFrequency = configuration.getSecureAtInceptionExecutionFrequency();
    try {
        if (autoConfigureMcpServer) {
            const baseDir = path_1.default.join(os.homedir(), '.gemini', 'antigravity');
            const configPath = path_1.default.join(baseDir, 'mcp_config.json');
            if (!fs.existsSync(baseDir)) {
                logger_1.Logger.debug(`Antigravity base directory not found at ${baseDir}, skipping MCP configuration.`);
            }
            else {
                const cliPath = await configuration.getCliPath();
                const env = getSnykMcpEnv(configuration);
                await ensureMcpServerInJson(configPath, SERVER_KEY, cliPath, ['mcp', '-t', 'stdio'], env);
                logger_1.Logger.debug(`Ensured Antigravity MCP config at ${configPath}`);
            }
        }
    }
    catch {
        logger_1.Logger.error('Failed to update Antigravity MCP config');
    }
    const localPath = path_1.default.join('.agent', 'rules', 'snyk_rules.md');
    try {
        if (secureAtInceptionExecutionFrequency === 'Manual') {
            // Delete rules from project
            await deleteLocalRulesForIde(localPath);
            return;
        }
        const rulesContent = await readBundledRules(vscodeContext, secureAtInceptionExecutionFrequency);
        await writeLocalRulesForIde(localPath, rulesContent);
        // Known antigravity bug: ignored rules for antigravity are not recognized.
    }
    catch {
        logger_1.Logger.error('Failed to publish Antigravity rules');
    }
}
exports.configureAntigravity = configureAntigravity;
async function configureCursor(vscodeContext, configuration) {
    const autoConfigureMcpServer = configuration.getAutoConfigureMcpServer();
    const secureAtInceptionExecutionFrequency = configuration.getSecureAtInceptionExecutionFrequency();
    try {
        if (autoConfigureMcpServer) {
            const configPath = path_1.default.join(os.homedir(), '.cursor', 'mcp.json');
            const cliPath = await configuration.getCliPath();
            const env = getSnykMcpEnv(configuration);
            await ensureMcpServerInJson(configPath, SERVER_KEY, cliPath, ['mcp', '-t', 'stdio'], env);
            logger_1.Logger.debug(`Ensured Cursor MCP config at ${configPath}`);
        }
    }
    catch {
        logger_1.Logger.error('Failed to update Cursor MCP config');
    }
    const cursorRulesPath = path_1.default.join('.cursor', 'rules', 'snyk_rules.mdc');
    try {
        if (secureAtInceptionExecutionFrequency === 'Manual') {
            // Delete rules from project (Cursor doesn't support global rules)
            await deleteLocalRulesForIde(cursorRulesPath);
            return;
        }
        const rulesContent = await readBundledRules(vscodeContext, secureAtInceptionExecutionFrequency);
        await writeLocalRulesForIde(cursorRulesPath, rulesContent);
        await ensureInGitignore([CURSOR_GITIGNORE_PATTERN]);
    }
    catch {
        logger_1.Logger.error('Failed to publish Cursor rules');
    }
}
exports.configureCursor = configureCursor;
async function ensureMcpServerInJson(filePath, serverKey, command, args, env) {
    let raw = undefined;
    if (fs.existsSync(filePath)) {
        try {
            raw = JSON.parse(await fs.promises.readFile(filePath, 'utf8'));
        }
        catch {
            // ignore parse error; will recreate minimal structure
        }
    }
    const config = { mcpServers: {} };
    if (raw && typeof raw === 'object' && raw !== null && Object.prototype.hasOwnProperty.call(raw, 'mcpServers')) {
        const servers = raw.mcpServers;
        if (servers && typeof servers === 'object') {
            config.mcpServers = servers;
        }
    }
    const serverKeyLower = serverKey.toLowerCase();
    let matchedKey = undefined;
    for (const key of Object.keys(config.mcpServers)) {
        const lower = key.toLowerCase();
        if (lower === serverKeyLower || lower.includes(serverKeyLower)) {
            matchedKey = key;
            break;
        }
    }
    const keyToUse = matchedKey !== null && matchedKey !== void 0 ? matchedKey : serverKey;
    const existing = config.mcpServers[keyToUse];
    const desired = { command, args, env };
    // Merge env: keep existing keys; add or override Snyk keys
    let resultingEnv;
    if (existing && existing.env) {
        resultingEnv = { ...existing.env };
        const overrideKeys = ['SNYK_CFG_ORG', 'SNYK_API', 'IDE_CONFIG_PATH', 'TRUSTED_FOLDERS'];
        for (const k of overrideKeys) {
            if (typeof env[k] !== 'undefined') {
                resultingEnv[k] = env[k];
            }
        }
    }
    else {
        resultingEnv = { ...(env || {}) };
    }
    const needsWrite = !existing ||
        existing.command !== desired.command ||
        JSON.stringify(existing.args) !== JSON.stringify(desired.args) ||
        JSON.stringify(existing.env || {}) !== JSON.stringify(resultingEnv || {});
    if (!needsWrite)
        return;
    config.mcpServers[keyToUse] = { command, args, env: resultingEnv };
    await fs.promises.mkdir(path_1.default.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, JSON.stringify(config, null, 2), 'utf8');
}
async function readBundledRules(vsCodeContext, frequency) {
    const rulesFileName = frequency === 'Smart Scan' ? 'snyk_rules_smart_apply.md' : 'snyk_rules_always_apply.md';
    return await fs.promises.readFile(path_1.default.join(vsCodeContext.extensionPath, 'out', 'assets', rulesFileName), 'utf8');
}
async function writeLocalRulesForIde(relativeRulesPath, rulesContent) {
    const folders = vscode.workspace.workspaceFolders;
    if (!folders || folders.length === 0) {
        void vscode.window.showInformationMessage('No workspace folder found. Local rules require an open workspace.');
        return;
    }
    for (const folder of folders) {
        const root = folder.uri.fsPath;
        const rulesPath = path_1.default.join(root, relativeRulesPath);
        await fs.promises.mkdir(path_1.default.dirname(rulesPath), { recursive: true });
        let existing = '';
        try {
            existing = await fs.promises.readFile(rulesPath, 'utf8');
        }
        catch {
            // ignore
        }
        if (existing !== rulesContent) {
            await fs.promises.writeFile(rulesPath, rulesContent, 'utf8');
            logger_1.Logger.debug(`Wrote local rules to ${rulesPath}`);
        }
        else {
            logger_1.Logger.debug(`Local rules already up to date at ${rulesPath}.`);
        }
    }
}
async function deleteLocalRulesForIde(relativeRulesPath) {
    const folders = vscode.workspace.workspaceFolders;
    if (!folders || folders.length === 0) {
        return;
    }
    for (const folder of folders) {
        const root = folder.uri.fsPath;
        const rulesPath = path_1.default.join(root, relativeRulesPath);
        try {
            if (fs.existsSync(rulesPath)) {
                await fs.promises.unlink(rulesPath);
                logger_1.Logger.debug(`Deleted local rules from ${rulesPath}`);
            }
        }
        catch (err) {
            logger_1.Logger.debug(`Failed to delete local rules from ${rulesPath}: ${err}`);
        }
    }
}
async function ensureInGitignore(patterns) {
    const folders = vscode.workspace.workspaceFolders;
    if (!folders || folders.length === 0) {
        return;
    }
    await Promise.all(folders.map(async (folder) => {
        const gitignorePath = path_1.default.join(folder.uri.fsPath, '.gitignore');
        let content = '';
        try {
            content = await fs.promises.readFile(gitignorePath, 'utf8');
        }
        catch {
            logger_1.Logger.debug(`.gitignore does not exist at ${gitignorePath}`);
            return;
        }
        // Split into lines handling both \n and \r\n
        const lines = content.split(/\r?\n/);
        const missing = patterns.filter(p => !lines.some(line => line.trim() === p.trim()));
        if (missing.length === 0) {
            logger_1.Logger.debug(`Snyk rules already in .gitignore at ${gitignorePath}`);
            return;
        }
        const addition = `\n# Snyk Security Extension - AI Rules (auto-generated)\n${missing.join('\n')}\n`;
        const updated = content + addition;
        await fs.promises.writeFile(gitignorePath, updated, 'utf8');
        logger_1.Logger.debug(`Added Snyk rules to .gitignore at ${gitignorePath}: ${missing.join(', ')}`);
    }));
}
function getSnykMcpEnv(configuration) {
    const env = {};
    if (configuration.organization) {
        env.SNYK_CFG_ORG = configuration.organization;
    }
    if (configuration.snykApiEndpoint) {
        env.SNYK_API = configuration.snykApiEndpoint;
    }
    const trustedFolders = configuration.getTrustedFolders();
    if (trustedFolders.length > 0) {
        env.TRUSTED_FOLDERS = trustedFolders.join(';');
    }
    env.IDE_CONFIG_PATH = vscode.env.appName;
    return env;
}
//# sourceMappingURL=mcp.js.map