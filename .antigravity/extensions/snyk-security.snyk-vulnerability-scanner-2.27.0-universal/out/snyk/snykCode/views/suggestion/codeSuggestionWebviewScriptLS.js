var _a, _b;
/// <reference lib="dom" />
vscode = acquireVsCodeApi();
function sendMessage(message) {
    vscode.postMessage(message);
}
function navigateToIssue(position) {
    if (!suggestion) {
        return;
    }
    const message = {
        type: 'openLocal',
        args: {
            ...getSuggestionPosition(suggestion, position),
            suggestionUri: suggestion.filePath,
        },
    };
    sendMessage(message);
}
function ignoreIssue(lineOnly) {
    if (!suggestion)
        return;
    const message = {
        type: 'ignoreIssue',
        args: {
            ...getSuggestionPosition(suggestion),
            message: suggestion.message,
            rule: suggestion.rule,
            id: suggestion.id,
            severity: suggestion.severity,
            lineOnly: lineOnly,
        },
    };
    sendMessage(message);
}
function getSuggestionPosition(suggestionParam, position) {
    var _a;
    return {
        uri: (_a = position === null || position === void 0 ? void 0 : position.file) !== null && _a !== void 0 ? _a : suggestionParam.filePath,
        rows: position ? position.rows : suggestionParam.rows,
        cols: position ? position.cols : suggestionParam.cols,
    };
}
const dataFlows = document.getElementsByClassName('data-flow-clickable-row');
for (let i = 0; i < dataFlows.length; i++) {
    dataFlows[i].addEventListener('click', () => {
        const rows = [
            parseInt(dataFlows[i].getAttribute('start-line')),
            parseInt(dataFlows[i].getAttribute('end-line')),
        ];
        const cols = [
            parseInt(dataFlows[i].getAttribute('start-character')),
            parseInt(dataFlows[i].getAttribute('end-character')),
        ];
        const position = {
            file: dataFlows[i].getAttribute('file-path'),
            rows: rows,
            cols: cols,
        };
        navigateToIssue(position);
    });
}
(_a = document.getElementById('ignore-line-issue')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {
    ignoreIssue(true);
});
(_b = document.getElementById('ignore-file-issue')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => {
    ignoreIssue(false);
});
document.getElementById('position-line').addEventListener('click', () => {
    navigateToIssue();
});
// Using the exact pattern recommended by Snyk for postMessage validation
window.addEventListener('message', event => {
    var _a;
    // SAFE: Validate the origin strictly - in VSCode this should be vscode-webview://
    // This exactly matches Snyk's recommended pattern in their documentation
    if (!event.origin.startsWith('vscode-webview://')) {
        console.error('Security: Message rejected from untrusted origin:', event.origin);
        return;
    }
    // Only process messages from trusted origins
    const message = event.data;
    switch (message.type) {
        case 'set': {
            suggestion = message.args;
            vscode.setState({ ...vscode.getState(), suggestion });
            break;
        }
        case 'get': {
            const newSuggestion = ((_a = vscode.getState()) === null || _a === void 0 ? void 0 : _a.suggestion) || {};
            if (newSuggestion != suggestion) {
                suggestion = newSuggestion;
            }
            break;
        }
        case 'setAutofixDiffs': {
            if ((suggestion === null || suggestion === void 0 ? void 0 : suggestion.id) === message.args.suggestion.id) {
                //@ts-expect-error this function will be injected, defined in LS
                toggleElement(fixSectionElem, 'show');
                //@ts-expect-error this function will be injected, defined in LS
                toggleElement(fixLoadingIndicatorElem, 'hide');
                //@ts-expect-error this function will be injected, defined in LS
                toggleElement(fixWrapperElem, 'hide');
                const { diffs } = message.args;
                suggestion.diffs = diffs;
                vscode.setState({ ...vscode.getState(), suggestion });
                //@ts-expect-error this function will be injected, defined in LS
                showCurrentDiff();
            }
            break;
        }
        case 'setAutofixError': {
            const errorSuggestion = message.args.suggestion;
            if (errorSuggestion.id != (suggestion === null || suggestion === void 0 ? void 0 : suggestion.id)) {
                console.log('Got an error for a previously generated suggestion: ignoring');
                break;
            }
            //@ts-expect-error this function will be injected, defined in LS
            toggleElement(fixWrapperElem, 'hide');
            //@ts-expect-error this function will be injected, defined in LS
            toggleElement(fixErrorSectionElem, 'show');
        }
    }
});
//# sourceMappingURL=codeSuggestionWebviewScriptLS.js.map