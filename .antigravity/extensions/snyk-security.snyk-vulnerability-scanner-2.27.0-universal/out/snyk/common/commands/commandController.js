"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandController = void 0;
const lodash_1 = __importDefault(require("lodash"));
const ignoreFileUtils_1 = require("../../snykCode/utils/ignoreFileUtils");
const commands_1 = require("../constants/commands");
const general_1 = require("../constants/general");
const errorHandler_1 = require("../error/errorHandler");
const types_1 = require("./types");
class CommandController {
    constructor(openerService, authService, snykCode, iacService, ossService, workspace, commands, window, env, languageServer, logger, configuration, folderConfigs) {
        this.openerService = openerService;
        this.authService = authService;
        this.snykCode = snykCode;
        this.iacService = iacService;
        this.ossService = ossService;
        this.workspace = workspace;
        this.commands = commands;
        this.window = window;
        this.env = env;
        this.languageServer = languageServer;
        this.logger = logger;
        this.configuration = configuration;
        this.folderConfigs = folderConfigs;
        this.debouncedCommands = {};
    }
    openBrowser(url) {
        return this.executeCommand(commands_1.SNYK_OPEN_BROWSER_COMMAND, this.openerService.openBrowserUrl.bind(this), url);
    }
    async initiateLogin() {
        this.logger.info('Initiating login');
        await this.executeCommand(commands_1.SNYK_INITIATE_LOGIN_COMMAND, this.authService.initiateLogin.bind(this.authService));
        await this.commands.executeCommand(commands_1.SNYK_TRUST_WORKSPACE_FOLDERS_COMMAND);
        await this.commands.executeCommand(commands_1.SNYK_LOGIN_COMMAND);
    }
    async setToken() {
        await this.executeCommand(commands_1.SNYK_SET_TOKEN_COMMAND, this.authService.setToken.bind(this.authService));
    }
    async openLocal(path, range) {
        try {
            await this.window.showTextDocumentViaUri(path, {
                viewColumn: 1,
                selection: range,
            });
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger);
        }
    }
    async openLocalFile(filePath, range) {
        try {
            await this.window.showTextDocumentViaFilepath(filePath, {
                viewColumn: 1,
                selection: range,
            });
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger);
        }
    }
    async setBaseBranch(folderPath) {
        await this.folderConfigs.setBranch(this.window, this.configuration, folderPath);
    }
    async setReferenceFolder(folderPath) {
        await this.folderConfigs.setReferenceFolder(this.window, this.configuration, folderPath);
    }
    async toggleDelta(isEnabled) {
        await this.configuration.setDeltaFindingsEnabled(isEnabled);
    }
    openSettings() {
        void this.commands.executeCommand(commands_1.VSCODE_GO_TO_SETTINGS_COMMAND, `@ext:${this.configuration.getExtensionId()}`);
    }
    async createDCIgnore(custom = false, uriAdapter, path) {
        if (!path) {
            const paths = this.workspace.getWorkspaceFolderPaths();
            const promises = [];
            for (const p of paths) {
                promises.push((0, ignoreFileUtils_1.createDCIgnore)(p, custom, this.workspace, this.window, uriAdapter));
            }
            await Promise.all(promises);
        }
        else {
            await (0, ignoreFileUtils_1.createDCIgnore)(path, custom, this.workspace, this.window, uriAdapter);
        }
    }
    async openIssueCommand(arg) {
        if (arg.issueType == types_1.OpenCommandIssueType.CodeIssue) {
            const issueArgs = arg.issue;
            const issue = this.snykCode.getIssue(issueArgs.folderPath, issueArgs.id);
            if (!issue) {
                this.logger.warn(`Failed to find the issue ${issueArgs.id}.`);
                return;
            }
            await this.openLocalFile(issue.filePath, issueArgs.range);
            try {
                await this.snykCode.showSuggestionProvider(issueArgs.folderPath, issueArgs.id);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
        }
        else if (arg.issueType == types_1.OpenCommandIssueType.OssVulnerability) {
            const issueArgs = arg.issue;
            const folderPath = issueArgs.folderPath;
            const issue = this.ossService.getIssue(folderPath, issueArgs.id);
            if (!issue) {
                this.logger.warn(`Failed to find the issue ${issueArgs.id}.`);
                return;
            }
            await this.openLocalFile(issue.filePath, issueArgs.range);
            try {
                await this.ossService.showSuggestionProvider(folderPath, issueArgs.id);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
        }
        else if (arg.issueType == types_1.OpenCommandIssueType.IacIssue) {
            const issueArgs = arg.issue;
            const issue = this.iacService.getIssue(issueArgs.folderPath, issueArgs.id);
            if (!issue) {
                this.logger.warn(`Failed to find the issue ${issueArgs.id}.`);
                return;
            }
            await this.openLocalFile(issue.filePath, issueArgs.range);
            try {
                await this.iacService.showSuggestionProvider(issueArgs.folderPath, issueArgs.id);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
        }
    }
    showOutputChannel() {
        return this.logger.showOutput();
    }
    async showLsOutputChannel(presentableError) {
        // To get an instance of an OutputChannel use createOutputChannel.
        this.languageServer.showOutputChannel();
        if (presentableError === null || presentableError === void 0 ? void 0 : presentableError.error) {
            // Format JSON as rows, excluding showNotification, treeNodeSuffix, and empty values
            const details = Object.entries(presentableError)
                .filter(([key]) => key !== 'showNotification' && key !== 'treeNodeSuffix')
                .filter(([, value]) => value !== undefined && value !== null && value !== '')
                .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
                .join('\n');
            const copyButton = 'Copy';
            const result = await this.window.showInformationMessage(details, {
                modal: true,
                detail: `You can copy the error message and use the filter field in the output channel to locate it.`,
            }, copyButton);
            if (result === copyButton) {
                await this.env.getClipboard().writeText(presentableError.error);
            }
        }
    }
    async executeCommand(name, fn, ...args) {
        if (!this.debouncedCommands[name])
            this.debouncedCommands[name] = lodash_1.default.debounce(async (...args) => {
                try {
                    return await fn(...args);
                }
                catch (error) {
                    errorHandler_1.ErrorHandler.handle(error, this.logger);
                    return Promise.resolve();
                }
            }, general_1.COMMAND_DEBOUNCE_INTERVAL, { leading: true, trailing: false });
        return this.debouncedCommands[name](...args);
    }
}
exports.CommandController = CommandController;
//# sourceMappingURL=commandController.js.map