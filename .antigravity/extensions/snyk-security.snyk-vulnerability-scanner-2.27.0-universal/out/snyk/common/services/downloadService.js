"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadService = void 0;
const rxjs_1 = require("rxjs");
const fsPromises = __importStar(require("fs/promises"));
const checksum_1 = require("../../cli/checksum");
const messages_1 = require("../../cli/messages/messages");
const globalState_1 = require("../constants/globalState");
const downloader_1 = require("../download/downloader");
const cliExecutable_1 = require("../../cli/cliExecutable");
const languageServer_1 = require("../constants/languageServer");
class DownloadService {
    constructor(extensionContext, configuration, cliApi, window, logger, downloader) {
        this.extensionContext = extensionContext;
        this.configuration = configuration;
        this.cliApi = cliApi;
        this.window = window;
        this.logger = logger;
        this.downloadReady$ = new rxjs_1.ReplaySubject(1);
        this.downloader = downloader !== null && downloader !== void 0 ? downloader : new downloader_1.Downloader(configuration, cliApi, window, logger, this.extensionContext);
    }
    async downloadOrUpdate() {
        const cliInstalled = await this.isCliInstalled();
        if (!this.configuration.isAutomaticDependencyManagementEnabled()) {
            this.downloadReady$.next();
            return false;
        }
        if (!cliInstalled) {
            const downloaded = await this.download();
            this.downloadReady$.next();
            return downloaded;
        }
        const updated = await this.update();
        this.downloadReady$.next();
        return updated;
    }
    async download() {
        this.logger.info(messages_1.messages.startingDownload);
        const executable = await this.downloader.download();
        if (!executable) {
            return false;
        }
        await this.setCliChecksum(executable.checksum);
        await this.setCliVersion(executable.version);
        this.logger.info(messages_1.messages.downloadFinished(executable.version));
        return true;
    }
    async update() {
        const platform = await cliExecutable_1.CliExecutable.getCurrentWithArch();
        const cliReleaseChannel = await this.configuration.getCliReleaseChannel();
        const version = await this.cliApi.getLatestCliVersion(cliReleaseChannel);
        if (!version) {
            return false;
        }
        const cliInstalled = await this.isCliInstalled();
        const cliVersionHasUpdated = this.hasCliVersionUpdated(version);
        const needsUpdate = cliVersionHasUpdated || this.hasLspVersionUpdated();
        if (!cliInstalled || needsUpdate) {
            const updateAvailable = await this.isCliUpdateAvailable(platform);
            if (!updateAvailable) {
                return false;
            }
            const executable = await this.downloader.download();
            if (!executable) {
                return false;
            }
            await this.setCliChecksum(executable.checksum);
            await this.setCliVersion(executable.version);
            await this.setCurrentLspVersion();
            this.logger.info(messages_1.messages.downloadFinished(executable.version));
            return true;
        }
        return false;
    }
    async isCliInstalled() {
        const cliExecutableExists = await cliExecutable_1.CliExecutable.exists(await this.configuration.getCliPath());
        const cliChecksumWritten = !!this.getCliChecksum();
        return cliExecutableExists && cliChecksumWritten;
    }
    async isCliUpdateAvailable(platform) {
        const cliReleaseChannel = await this.configuration.getCliReleaseChannel();
        const version = await this.cliApi.getLatestCliVersion(cliReleaseChannel);
        if (!version) {
            return false;
        }
        const latestChecksum = await this.cliApi.getSha256Checksum(version, platform);
        const path = await this.configuration.getCliPath();
        // migration for moving from default extension path to xdg dirs.
        if (cliExecutable_1.CliExecutable.isPathInExtensionDirectory(this.extensionContext.extensionPath, path)) {
            try {
                await fsPromises.unlink(path);
            }
            catch {
                // eslint-disable-next-line no-empty
            }
            await this.configuration.setCliPath(await cliExecutable_1.CliExecutable.getPath());
            return true;
        }
        // Update is available if fetched checksum not matching the current one
        try {
            const checksum = await checksum_1.Checksum.getChecksumOf(path, latestChecksum);
            if (checksum.verify()) {
                this.logger.info(messages_1.messages.isLatest);
                return false;
            }
        }
        catch {
            // if checksum check fails; force an update
            return true;
        }
        return true;
    }
    async setCliChecksum(checksum) {
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_CLI_CHECKSUM, checksum.checksum);
    }
    async setCliVersion(cliVersion) {
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_CLI_VERSION, cliVersion);
    }
    hasLspVersionUpdated() {
        const currentProtoclVersion = this.getLsProtocolVersion();
        return currentProtoclVersion != languageServer_1.PROTOCOL_VERSION;
    }
    async setCurrentLspVersion() {
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_LS_PROTOCOL_VERSION, languageServer_1.PROTOCOL_VERSION);
    }
    getLsProtocolVersion() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_LS_PROTOCOL_VERSION);
    }
    hasCliVersionUpdated(cliVersion) {
        const currentVersion = this.getCliVersion();
        return currentVersion != cliVersion;
    }
    getCliVersion() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_CLI_VERSION);
    }
    getCliChecksum() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_CLI_CHECKSUM);
    }
    /**
     * Verifies CLI integrity and redownloads if checksum doesn't match or file is corrupted.
     * Returns true if CLI is valid or was successfully redownloaded.
     */
    async verifyAndRepairCli() {
        if (!this.configuration.isAutomaticDependencyManagementEnabled()) {
            this.logger.info('Automatic dependency management disabled, skipping CLI verification');
            return false;
        }
        try {
            const cliPath = await this.configuration.getCliPath();
            const platform = await cliExecutable_1.CliExecutable.getCurrentWithArch();
            if (!platform) {
                this.logger.error('Unsupported platform for CLI verification');
                return false;
            }
            // Check if CLI file exists
            const cliExists = await cliExecutable_1.CliExecutable.exists(cliPath);
            if (!cliExists) {
                this.logger.info('CLI binary not found, downloading...');
                return await this.download();
            }
            // Get the expected checksum for the current version
            const cliReleaseChannel = await this.configuration.getCliReleaseChannel();
            const latestVersion = await this.cliApi.getLatestCliVersion(cliReleaseChannel);
            const expectedChecksum = await this.cliApi.getSha256Checksum(latestVersion, platform);
            // Verify the actual file checksum
            const actualChecksum = await checksum_1.Checksum.getChecksumOf(cliPath, expectedChecksum);
            if (actualChecksum.verify()) {
                this.logger.info('CLI checksum verification passed');
                return true;
            }
            else {
                this.logger.info('CLI checksum verification failed, redownloading...');
                return await this.download();
            }
        }
        catch (error) {
            this.logger.error(`CLI verification failed: ${error}`);
            this.logger.info('Attempting to redownload CLI...');
            try {
                return await this.download();
            }
            catch (downloadError) {
                this.logger.error(`CLI redownload failed: ${downloadError}`);
                return false;
            }
        }
    }
}
exports.DownloadService = DownloadService;
//# sourceMappingURL=downloadService.js.map