"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiIntegrationService = void 0;
const errorHandler_1 = require("../error/errorHandler");
const path_1 = __importDefault(require("path"));
const general_1 = require("../constants/general");
const types_1 = require("../languageServer/types");
const commands_1 = require("../constants/commands");
const mappings_1 = require("../services/mappings");
const fs_1 = require("fs");
class GeminiIntegrationService {
    constructor(logger, configuration, extensionContext, scan$, uriAdapter, markdownAdapter, codeCommands, diagnosticsProvider) {
        this.logger = logger;
        this.configuration = configuration;
        this.extensionContext = extensionContext;
        this.scan$ = scan$;
        this.uriAdapter = uriAdapter;
        this.markdownAdapter = markdownAdapter;
        this.codeCommands = codeCommands;
        this.diagnosticsProvider = diagnosticsProvider;
    }
    getBase64FromFilePath(filepath) {
        const fileContents = (0, fs_1.readFileSync)(filepath);
        return fileContents.toString('base64');
    }
    initImages() {
        const basePath = path_1.default.join(this.extensionContext.extensionPath, 'media/images');
        this.criticalBase64Image = this.getBase64FromFilePath(path_1.default.join(basePath, 'dark-critical-severity.svg'));
        this.highBase64Image = this.getBase64FromFilePath(path_1.default.join(basePath, 'dark-high-severity.svg'));
        this.mediumBase64Image = this.getBase64FromFilePath(path_1.default.join(basePath, 'dark-medium-severity.svg'));
        this.lowBase64Image = this.getBase64FromFilePath(path_1.default.join(basePath, 'dark-low-severity.svg'));
    }
    async connectGeminiToMCPServer() {
        try {
            const geminiCodeAssistExtension = this.extensionContext.getExtension('google.geminicodeassist');
            const isInstalled = !!geminiCodeAssistExtension;
            if (!isInstalled) {
                return Promise.resolve();
            }
            this.initImages();
            this.logger.info('found Gemini Code Assist extension');
            this.logger.debug('waiting for activation of gca');
            while (geminiCodeAssistExtension && !geminiCodeAssistExtension.isActive) {
                // eslint-disable-next-line no-await-in-loop
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            this.registerWithGeminiCodeAssist(geminiCodeAssistExtension === null || geminiCodeAssistExtension === void 0 ? void 0 : geminiCodeAssistExtension.exports);
        }
        catch (error) {
            return errorHandler_1.ErrorHandler.handle(error, this.logger, error instanceof Error ? error.message : 'An error occurred');
        }
        return Promise.resolve();
    }
    registerWithGeminiCodeAssist(geminiCodeAssist) {
        this.logger.info('Registering with Gemini Code Assist');
        try {
            const iconPath = path_1.default.join(this.extensionContext.extensionPath, 'media/images/readme/snyk_extension_icon.png');
            const iconURI = this.uriAdapter.file(iconPath);
            const geminiTool = geminiCodeAssist.registerTool('Snyk', general_1.SNYK_NAME, general_1.SNYK_NAME_EXTENSION, iconURI);
            geminiTool.registerChatHandler(this.getChatRequestHandler());
            const commandProvider = {
                listCommands() {
                    const commands = [
                        {
                            command: 'scan',
                            description: 'Perform a workspace scan with the Snyk Security Extension',
                            icon: iconPath,
                        },
                        {
                            command: 'show',
                            description: 'Show issues known to the Snyk Security Extension',
                            icon: iconPath,
                        },
                    ];
                    return Promise.resolve(commands);
                },
            };
            geminiTool.registerCommandProvider(commandProvider);
            const suggestedPromptProvider = this.getSuggestedPromptProvider();
            geminiTool.registerSuggestedPromptProvider(suggestedPromptProvider);
        }
        catch (error) {
            return errorHandler_1.ErrorHandler.handle(error, this.logger, error instanceof Error ? error.message : 'An error occurred');
        }
    }
    getSuggestedPromptProvider() {
        const suggestedPromptProvider = {
            provideSuggestedPrompts: () => {
                return ['/scan', '/show', '/scan for new', '/show new', '/scan all', '/show all'];
            },
        };
        return suggestedPromptProvider;
    }
    getChatRequestHandler() {
        return async (request, responseStream, token) => {
            this.logger.debug('received chat request from gemini: ' + request.prompt.fullPrompt());
            if (token.isCancellationRequested)
                return Promise.resolve();
            if (!request.prompt.fullPrompt().includes('scan') && !request.prompt.fullPrompt().includes('show')) {
                responseStream.push(this.markdownAdapter.get('It seems, you tried to invoke the Snyk Security tool integration. Unfortunately, we were not able to recognize the command you sent. You can try `@snyk /scan` to scan for issues and display them here.', true));
                responseStream.close();
                return Promise.resolve();
            }
            await this.handleDelta(request, responseStream);
            if (request.prompt.fullPrompt().includes('scan')) {
                responseStream.push(this.markdownAdapter.get('Scanning workspace with Snyk...'));
                let openScansCount = this.countEnabledProducts();
                // subscribe to snyk scan topic to get issue data
                this.scan$.subscribe((scan) => {
                    // const msg = 'Scan status for ' + scan.folderPath + ': ' + scan.status + '.';
                    // responseStream.push(this.markdownAdapter.get(msg));
                    if (scan.status == types_1.ScanStatus.Success || scan.status == types_1.ScanStatus.Error) {
                        openScansCount--;
                    }
                });
                await this.codeCommands.executeCommand(commands_1.SNYK_WORKSPACE_SCAN_COMMAND, 'LLM');
                while (openScansCount > 0) {
                    // eslint-disable-next-line no-await-in-loop
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            // show
            const markdown = this.markdownAdapter.get(this.getIssueMarkDownFromDiagnostics(request.context), true);
            markdown.isTrusted = { enabledCommands: [commands_1.SNYK_NAVIGATE_TO_RANGE] };
            markdown.supportHtml = true;
            responseStream.push(markdown);
            responseStream.close();
            return Promise.resolve();
        };
    }
    async handleDelta(request, responseStream) {
        if (request.prompt.fullPrompt().includes('new') && !this.configuration.getDeltaFindingsEnabled()) {
            await this.configuration.setDeltaFindingsEnabled(true);
            responseStream.push(this.markdownAdapter.get('Enabled net-new issues feature...'));
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        if (request.prompt.fullPrompt().includes('all') && this.configuration.getDeltaFindingsEnabled()) {
            await this.configuration.setDeltaFindingsEnabled(false);
            responseStream.push(this.markdownAdapter.get('Disabled net-new issues feature...'));
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
    countEnabledProducts() {
        var _a, _b, _c;
        const enabledProducts = [];
        if ((_a = this.configuration.getFeaturesConfiguration()) === null || _a === void 0 ? void 0 : _a.ossEnabled)
            enabledProducts.push(types_1.ScanProduct.OpenSource);
        if ((_b = this.configuration.getFeaturesConfiguration()) === null || _b === void 0 ? void 0 : _b.codeSecurityEnabled)
            enabledProducts.push(types_1.ScanProduct.Code);
        if ((_c = this.configuration.getFeaturesConfiguration()) === null || _c === void 0 ? void 0 : _c.iacEnabled)
            enabledProducts.push(types_1.ScanProduct.InfrastructureAsCode);
        return enabledProducts.length;
    }
    toNumericSeverity(i1) {
        let i1NumSeverity;
        switch (i1.severity) {
            case types_1.IssueSeverity.Critical:
                i1NumSeverity = 0;
                break;
            case types_1.IssueSeverity.High:
                i1NumSeverity = 1;
                break;
            case types_1.IssueSeverity.Medium:
                i1NumSeverity = 2;
                break;
            case types_1.IssueSeverity.Low:
                i1NumSeverity = 3;
                break;
        }
        return i1NumSeverity;
    }
    getIssueMarkDownFromDiagnostics(context) {
        let issueMsg = 'No issues found.';
        const issueComparator = (i1, i2) => {
            const i1NumSeverity = this.toNumericSeverity(i1);
            const i2NumSeverity = this.toNumericSeverity(i2);
            const i1Score = this.getScore(i1);
            const i2Score = this.getScore(i2);
            if (i1NumSeverity < i2NumSeverity)
                return -1;
            if (i1NumSeverity > i2NumSeverity)
                return 1;
            if (i1Score < i2Score)
                return 1;
            if (i1Score > i2Score)
                return -1;
            if (i1.title < i2.title)
                return -1;
            if (i1.title > i2.title)
                return 1;
            return 0;
        };
        function pushIssuesToContext(issues) {
            const issuesString = 'These are ' +
                issues[0].filterableIssueType +
                ' issues that Snyk has found in JSON format: ' +
                JSON.stringify(issues);
            const newContext = {
                id: 'snyk-workspace-scan',
                getText: () => issuesString,
            };
            context.push(newContext);
        }
        try {
            const codeIssues = this.diagnosticsProvider.getIssuesFromDiagnostics(types_1.ScanProduct.Code);
            const ossIssues = this.diagnosticsProvider.getIssuesFromDiagnostics(types_1.ScanProduct.OpenSource);
            const iacIssues = this.diagnosticsProvider.getIssuesFromDiagnostics(types_1.ScanProduct.InfrastructureAsCode);
            if (codeIssues.length > 0 || ossIssues.length > 0 || iacIssues.length > 0) {
                issueMsg = '';
            }
            if (codeIssues.length > 0) {
                codeIssues.sort(issueComparator);
                pushIssuesToContext(codeIssues);
                issueMsg += '\n\n## ' + (0, mappings_1.productToLsProduct)(types_1.ScanProduct.Code) + ' Issues\n';
                issueMsg += '|Sev  |⚡️    | Issue                                             | Score | \n';
                issueMsg += '|-----|------|:------------------------------------------|------:| \n';
                for (const issue of codeIssues) {
                    issueMsg += this.enrichMessageWithIssueData(issue, types_1.ScanProduct.Code);
                }
            }
            if (ossIssues.length > 0) {
                ossIssues.sort(issueComparator);
                pushIssuesToContext(ossIssues);
                issueMsg += '\n\n## ' + (0, mappings_1.productToLsProduct)(types_1.ScanProduct.OpenSource) + ' Issues\n';
                issueMsg += '|Sev  |⚡️    | Issue                                             | Score | \n';
                issueMsg += '|-----|------|:------------------------------------------|------:| \n';
                for (const issue of ossIssues) {
                    issueMsg += this.enrichMessageWithIssueData(issue, types_1.ScanProduct.OpenSource);
                }
            }
            if (iacIssues.length > 0) {
                iacIssues.sort(issueComparator);
                pushIssuesToContext(iacIssues);
                issueMsg += '\n\n## ' + (0, mappings_1.productToLsProduct)(types_1.ScanProduct.InfrastructureAsCode) + ' Issues\n';
                issueMsg += '|Sev  |⚡️    | Issue                                             | Score | \n';
                issueMsg += '|-----|------|:------------------------------------------|------:| \n';
                for (const issue of iacIssues) {
                    issueMsg += this.enrichMessageWithIssueData(issue, types_1.ScanProduct.InfrastructureAsCode);
                }
            }
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger, e instanceof Error ? e.message : 'An error occurred');
        }
        return issueMsg;
    }
    enrichMessageWithIssueData(issue, scanProduct) {
        const baseName = path_1.default.basename(issue.filePath);
        const snykUri = 'snyk://' +
            encodeURI(issue.filePath) +
            '?product=' +
            encodeURI((0, mappings_1.productToLsProduct)(scanProduct)) +
            '&issueId=' +
            encodeURI(issue.id) +
            '&action=showInDetailPanel';
        const params = encodeURI(JSON.stringify([snykUri, issue.range]));
        const commandURI = this.uriAdapter.parse(`command:${commands_1.SNYK_NAVIGATE_TO_RANGE}?${params}`);
        const titleLink = `[**` + issue.title.split(':')[0] + `**](${commandURI})`;
        const score = this.getScore(issue);
        let emoji;
        switch (issue.severity) {
            case types_1.IssueSeverity.Critical:
                emoji = `<img src="data:image/svg+xml;base64,${this.criticalBase64Image}" alt="Critical">`;
                break;
            case types_1.IssueSeverity.High:
                emoji = `<img src="data:image/svg+xml;base64,${this.highBase64Image}" alt="High">`;
                break;
            case types_1.IssueSeverity.Medium:
                emoji = `<img src="data:image/svg+xml;base64,${this.mediumBase64Image}" alt="Medium">`;
                break;
            default:
                emoji = `<img src="data:image/svg+xml;base64,${this.lowBase64Image}" alt="Low">`;
                break;
        }
        const line = issue.range.start.line + 1;
        const bolt = `${this.isFixable(issue) ? '⚡️' : ''}`;
        return `| ${emoji} | ${bolt} | ${titleLink} <br> <small>${baseName}#L${line}</small>| \`${score}\` |\n`;
    }
    isFixable(issue) {
        let fixable;
        switch (issue.filterableIssueType) {
            case 'Code Security':
                fixable = issue.additionalData.hasAIFix;
                break;
            case 'Open Source':
                fixable = issue.additionalData.isUpgradable;
                break;
            default:
                fixable = false;
                break;
        }
        return fixable;
    }
    getScore(issue) {
        var _a;
        let score;
        switch (issue.filterableIssueType) {
            case 'Code Security':
                score = issue.additionalData.priorityScore;
                break;
            case 'Open Source':
                score = (_a = issue.additionalData.cvssScore) !== null && _a !== void 0 ? _a : 0;
                break;
            default:
                score = Math.abs(this.toNumericSeverity(issue) - 100);
                break;
        }
        return score;
    }
}
exports.GeminiIntegrationService = GeminiIntegrationService;
//# sourceMappingURL=geminiIntegrationService.js.map