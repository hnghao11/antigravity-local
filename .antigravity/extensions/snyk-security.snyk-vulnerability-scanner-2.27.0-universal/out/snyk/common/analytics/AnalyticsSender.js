"use strict";
// noinspection InfiniteLoopJS
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsSender = void 0;
const time_1 = require("@amplitude/experiment-node-server/dist/src/util/time");
const commands_1 = require("../constants/commands");
const views_1 = require("../constants/views");
class AnalyticsSender {
    constructor(logger, configuration, commandExecutor, contextService) {
        this.logger = logger;
        this.configuration = configuration;
        this.commandExecutor = commandExecutor;
        this.contextService = contextService;
        this.eventQueue = [];
        void this.start();
    }
    static getInstance(logger, configuration, commandExecutor, contextService) {
        if (!AnalyticsSender.instance) {
            AnalyticsSender.instance = new AnalyticsSender(logger, configuration, commandExecutor, contextService);
        }
        return AnalyticsSender.instance;
    }
    async start() {
        var _a;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // eslint-disable-next-line no-await-in-loop
            const authToken = await this.configuration.getToken();
            const initialized = (_a = this.contextService.viewContext[views_1.SNYK_CONTEXT.INITIALIZED]) !== null && _a !== void 0 ? _a : false;
            const hasEvents = this.eventQueue.length > 0;
            const authenticated = authToken && authToken.trim() !== '';
            const iAmTired = !(initialized && authenticated && hasEvents);
            if (iAmTired) {
                // eslint-disable-next-line no-await-in-loop
                await (0, time_1.sleep)(5000);
                continue;
            }
            const copyForSending = [...this.eventQueue];
            for (let i = 0; i < copyForSending.length; i++) {
                const eventPair = copyForSending[i];
                try {
                    // eslint-disable-next-line no-await-in-loop
                    await this.commandExecutor.executeCommand(commands_1.SNYK_REPORT_ANALYTICS, JSON.stringify(eventPair.event));
                    eventPair.callback();
                }
                catch (error) {
                    // eslint-disable-next-line @typescript-eslint/no-base-to-string
                    this.logger.error(`could not send ${eventPair.event} ${error}`);
                }
                finally {
                    // let's not rely on indexes in the eventQueue array not having changed
                    const index = this.eventQueue.indexOf(eventPair);
                    if (index > -1) {
                        this.eventQueue.splice(index, 1);
                    }
                }
            }
        }
    }
    logEvent(event, callback) {
        this.eventQueue.push({ event, callback });
    }
}
exports.AnalyticsSender = AnalyticsSender;
//# sourceMappingURL=AnalyticsSender.js.map