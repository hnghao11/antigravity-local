"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageServer = void 0;
const lodash_1 = __importDefault(require("lodash"));
const rxjs_1 = require("rxjs");
const languageServer_1 = require("../constants/languageServer");
const settings_1 = require("../constants/settings");
const errorHandler_1 = require("../error/errorHandler");
const middleware_1 = require("./middleware");
const settings_2 = require("./settings");
const geminiIntegrationService_1 = require("../llm/geminiIntegrationService");
class LanguageServer {
    static isLSUpdatingOrg(folderPath) {
        return LanguageServer.foldersBeingUpdatedByLS.has(folderPath);
    }
    constructor(user, configuration, languageClientAdapter, workspace, window, authenticationService, logger, downloadService, extensionRetriever, summaryProvider, uriAdapter, markdownAdapter, codeCommands, diagnosticsProvider) {
        this.user = user;
        this.configuration = configuration;
        this.languageClientAdapter = languageClientAdapter;
        this.workspace = workspace;
        this.window = window;
        this.authenticationService = authenticationService;
        this.logger = logger;
        this.downloadService = downloadService;
        this.extensionRetriever = extensionRetriever;
        this.summaryProvider = summaryProvider;
        this.uriAdapter = uriAdapter;
        this.markdownAdapter = markdownAdapter;
        this.codeCommands = codeCommands;
        this.diagnosticsProvider = diagnosticsProvider;
        this.cliReady$ = new rxjs_1.ReplaySubject(1);
        this.scan$ = new rxjs_1.Subject();
        this.showIssueDetailTopic$ = new rxjs_1.Subject();
        this.downloadService = downloadService;
        this.geminiIntegrationService = new geminiIntegrationService_1.GeminiIntegrationService(this.logger, this.configuration, this.extensionRetriever, this.scan$, this.uriAdapter, this.markdownAdapter, this.codeCommands, this.diagnosticsProvider);
    }
    // Starts the language server and the client. LS will be downloaded if missing.
    // Returns a promise that resolves when the language server is ready to receive requests.
    async start() {
        var _a, _b, _c;
        // wait until Snyk LS is downloaded
        await (0, rxjs_1.firstValueFrom)(this.downloadService.downloadReady$);
        this.logger.info('Starting Snyk Language Server');
        // proxy settings - get directly from VSCode configuration
        const httpProxy = this.workspace.getConfiguration('http', 'proxy');
        let processEnv = process.env;
        if (httpProxy) {
            processEnv = {
                ...processEnv,
                HTTPS_PROXY: httpProxy,
                HTTP_PROXY: httpProxy,
            };
        }
        const cliBinaryPath = await this.configuration.getCliPath();
        // log level is set to info by default
        let logLevel = 'info';
        const additionalCliParameters = this.configuration.getAdditionalCliParameters();
        if (additionalCliParameters != null &&
            additionalCliParameters.length > 0 &&
            (additionalCliParameters.includes('-d') || additionalCliParameters.includes('--debug'))) {
            logLevel = 'debug';
        }
        logLevel = (_a = process.env.SNYK_LOG_LEVEL) !== null && _a !== void 0 ? _a : logLevel;
        const args = ['language-server', '-l', logLevel];
        this.logger.info(`Snyk Language Server - path: ${cliBinaryPath}`);
        this.logger.info(`Snyk Language Server - args: ${args}`);
        const serverOptions = {
            command: cliBinaryPath,
            args: args,
            options: {
                env: processEnv,
            },
        };
        // Options to control the language client
        const clientOptions = {
            documentSelector: [{ scheme: 'file', language: '' }],
            initializationOptions: await this.getInitializationOptions(),
            synchronize: {
                configurationSection: settings_1.CONFIGURATION_IDENTIFIER,
            },
            middleware: new middleware_1.LanguageClientMiddleware(this.logger, this.configuration, this.user, this.showIssueDetailTopic$),
            /**
             * We reuse the output channel here as it's not properly disposed of by the language client (vscode-languageclient@8.0.0-next.2)
             * See: https://github.com/microsoft/vscode-languageserver-node/blob/cdf4d6fdaefe329ce417621cf0f8b14e0b9bb39d/client/src/common/client.ts#L2789
             */
            outputChannel: (_c = (_b = this.client) === null || _b === void 0 ? void 0 : _b.outputChannel) !== null && _c !== void 0 ? _c : this.window.createOutputChannel(languageServer_1.SNYK_LANGUAGE_SERVER_NAME),
        };
        // Create the language client and start the client.
        this.client = this.languageClientAdapter.create('SnykLS', languageServer_1.SNYK_LANGUAGE_SERVER_NAME, serverOptions, clientOptions);
        try {
            // register listeners before starting the client
            this.registerListeners(this.client);
            // Start the client. This will also launch the server
            await this.client.start();
            void this.geminiIntegrationService.connectGeminiToMCPServer();
            this.logger.info('Snyk Language Server started');
        }
        catch (error) {
            this.logger.error(`Language Server startup failed: ${error instanceof Error ? error.message : 'An error occurred'}`);
            // If startup failed and automatic downloads are enabled, verify CLI integrity
            if (this.configuration.isAutomaticDependencyManagementEnabled()) {
                this.logger.info('Verifying CLI integrity and attempting repair...');
                const cliRepaired = await this.downloadService.verifyAndRepairCli();
                if (cliRepaired) {
                    this.logger.info('CLI repaired, retrying Language Server startup...');
                    try {
                        // Recreate the client with the same options since the previous one may be in a bad state
                        this.client = this.languageClientAdapter.create('SnykLS', languageServer_1.SNYK_LANGUAGE_SERVER_NAME, serverOptions, clientOptions);
                        this.registerListeners(this.client);
                        await this.client.start();
                        void this.geminiIntegrationService.connectGeminiToMCPServer();
                        this.logger.info('Snyk Language Server started successfully after CLI repair');
                        return;
                    }
                    catch (retryError) {
                        this.logger.error(`Language Server startup failed even after CLI repair: ${retryError instanceof Error ? retryError.message : 'An error occurred'}`);
                    }
                }
            }
            return errorHandler_1.ErrorHandler.handle(error, this.logger, error instanceof Error ? error.message : 'An error occurred');
        }
    }
    registerListeners(client) {
        client.onNotification(languageServer_1.SNYK_HAS_AUTHENTICATED, ({ token, apiUrl }) => {
            this.authenticationService.updateTokenAndEndpoint(token, apiUrl).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_FOLDERCONFIG, ({ folderConfigs }) => {
            // Process each folder config: merge on first receipt, handle org settings on subsequent receipts
            const processedFolderConfigs = folderConfigs.map(folderConfig => {
                const isFirstReceipt = !this.configuration
                    .getFolderConfigs()
                    .find(cachedFC => cachedFC.folderPath === folderConfig.folderPath);
                if (isFirstReceipt) {
                    // First time receiving config for this folder - merge VS Code settings into LS config
                    return this.mergeOrgSettingsIntoLSFolderConfig(folderConfig);
                }
                // Subsequent receipt - return as-is (will be handled by handleOrgSettingsFromFolderConfigs)
                return folderConfig;
            });
            // Update org settings in VS Code UI to reflect the current state
            this.handleOrgSettingsFromFolderConfigs(processedFolderConfigs);
            // Set global flag after first folder config received (used for initialization options)
            LanguageServer.ReceivedFolderConfigsFromLs = true;
            this.configuration.setFolderConfigs(processedFolderConfigs).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error instanceof Error ? error.message : 'An error occurred');
            });
        });
        client.onNotification(languageServer_1.SNYK_ADD_TRUSTED_FOLDERS, ({ trustedFolders }) => {
            this.configuration.setTrustedFolders(trustedFolders).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_SCAN, (scan) => {
            this.logger.info(`${lodash_1.default.capitalize(scan.product)} scan for ${scan.folderPath}: ${scan.status}.`);
            this.scan$.next(scan);
        });
        client.onNotification(languageServer_1.SNYK_SCANSUMMARY, ({ scanSummary }) => {
            this.summaryProvider.updateSummaryPanel(scanSummary);
        });
    }
    // Initialization options are not semantically equal to server settings, thus separated here
    // https://github.com/microsoft/language-server-protocol/issues/567
    async getInitializationOptions() {
        return await settings_2.LanguageServerSettings.fromConfiguration(this.configuration, this.user);
    }
    showOutputChannel() {
        if (!this.client) {
            return;
        }
        this.client.outputChannel.show();
    }
    handleOrgSettingsFromFolderConfigs(folderConfigs) {
        const currentWorkspaceFolders = this.workspace.getWorkspaceFolders();
        folderConfigs.forEach(folderConfig => {
            // Only write folder level org settings for folders that have been migrated from global config
            if (!folderConfig.orgMigratedFromGlobalConfig) {
                return;
            }
            // Only set organization for folders that are part of the current VS Code workspace
            const workspaceFolder = currentWorkspaceFolders.find(workspaceFolder => folderConfig.folderPath === workspaceFolder.uri.fsPath);
            if (!workspaceFolder) {
                this.logger.warn(`No workspace folder found for path: ${folderConfig.folderPath}`);
                return;
            }
            const orgToDisplay = folderConfig.orgSetByUser ? folderConfig.preferredOrg : folderConfig.autoDeterminedOrg;
            // Mark this folder as being updated by LS to prevent circular updates in the watcher
            LanguageServer.foldersBeingUpdatedByLS.add(folderConfig.folderPath);
            // TODO - await this call when we update vscode-languageclient to a version that supports async notification handlers.
            this.configuration
                .setOrganization(workspaceFolder, orgToDisplay)
                .then(() => {
                this.logger.debug(`Set organization "${orgToDisplay}" for workspace folder: ${folderConfig.folderPath} (orgSetByUser: ${folderConfig.orgSetByUser})`);
            }, error => {
                this.logger.warn(`Failed to set organization for folder ${folderConfig.folderPath}: ${error}`);
            })
                .finally(() => {
                // Clear the flag after update completes (whether success or error)
                LanguageServer.foldersBeingUpdatedByLS.delete(folderConfig.folderPath);
            });
            // Set auto-organization at workspace folder level only if the desired value differs from
            // the current configuration value when querying all levels (folder, workspace, global, default).
            // Unless the desired auto-org is true (selected), then it should be written at the folder level.
            const desiredAutoOrg = !folderConfig.orgSetByUser;
            const currentAutoOrg = this.configuration.isAutoSelectOrganizationEnabled(workspaceFolder);
            if (desiredAutoOrg !== currentAutoOrg || desiredAutoOrg) {
                // TODO - await this call when we update vscode-languageclient to a version that supports async notification handlers.
                this.configuration.setAutoSelectOrganization(workspaceFolder, desiredAutoOrg).then(() => {
                    this.logger.debug(`Set auto-organization to ${desiredAutoOrg} for workspace folder: ${folderConfig.folderPath}`);
                }, error => {
                    this.logger.warn(`Failed to set auto-organization for folder ${folderConfig.folderPath}: ${error}`);
                });
            }
        });
    }
    mergeOrgSettingsIntoLSFolderConfig(folderConfig) {
        var _a;
        const workspaceFolder = this.workspace.getWorkspaceFolder(folderConfig.folderPath);
        if (!workspaceFolder) {
            // LS must be crazy, we don't know of this folder, so we will just store it as-is.
            return folderConfig;
        }
        const orgSetByUser = !this.configuration.isAutoSelectOrganizationEnabled(workspaceFolder);
        if (orgSetByUser) {
            return {
                ...folderConfig,
                preferredOrg: (_a = this.configuration.getOrganizationAtWorkspaceFolderLevel(workspaceFolder)) !== null && _a !== void 0 ? _a : '',
                orgSetByUser: true,
            };
        }
        else {
            return {
                ...folderConfig,
                orgSetByUser: false,
            };
        }
    }
    async stop() {
        var _a;
        this.logger.info('Stopping Snyk Language Server...');
        if (!this.client) {
            return Promise.resolve();
        }
        if ((_a = this.client) === null || _a === void 0 ? void 0 : _a.needsStop()) {
            await this.client.stop();
        }
        this.logger.info('Snyk Language Server stopped');
    }
}
exports.LanguageServer = LanguageServer;
LanguageServer.ReceivedFolderConfigsFromLs = false;
// Track folder paths where LS is updating org settings to prevent circular updates
LanguageServer.foldersBeingUpdatedByLS = new Set();
//# sourceMappingURL=languageServer.js.map